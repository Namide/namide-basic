package namide.basic.display {	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Point;	public class BitmapDataResizerBilinear	{		public static const METHOD_PAN_AND_SCAN:String = "panAndScan";		public static const METHOD_LETTERBOX:String = "letterbox";		public static const METHOD_RAW:String = "raw";				public function BitmapDataResizerBilinear() { }		public static function bilinear( source:BitmapData, width:uint, height:uint, method:String, allowEnlarging:Boolean = true ):BitmapData        {            var scale:Point = ResizeMath.scale( new Point(source.width, source.height), new Point(width, height), method, allowEnlarging);            var result:BitmapData = new BitmapData(width, height, true, 0x0);            var matrix:Matrix = new Matrix();            matrix.scale(scale.x, scale.y);            matrix.tx = (width - source.width * scale.x) / 2;            matrix.ty = (height - source.height * scale.y) / 2;            result.draw(source, matrix, null, null, null, true);            return result;        }                public static function bilinearIterative( source:BitmapData, width:uint, height:uint, method:String, allowEnlarging:Boolean = true, iterationMultiplier:Number = 2 ):BitmapData        {            var w:uint = source.width;            var h:uint = source.height;            var result:BitmapData;            while(!result || w != width || h != height)            {                w = source.width > width ? Math.max(w / iterationMultiplier, width) : Math.min(w * iterationMultiplier, width);                h = source.height > height ? Math.max(h / iterationMultiplier, height) : Math.min(h * iterationMultiplier, height);                result = bilinear(result || source, w, h, method, allowEnlarging);            }            return result;        }	}	}import flash.geom.Point;import namide.basic.display.BitmapDataResizerBilinear;internal class ResizeMath{		public function ResizeMath() { }		public static function fixMethod(method:String):String	{		return (method == BitmapDataResizerBilinear.METHOD_PAN_AND_SCAN || method == BitmapDataResizerBilinear.METHOD_LETTERBOX) ? method : BitmapDataResizerBilinear.METHOD_RAW;	}		public static function newDimensions(origDimensions:Point, containerDimensions:Point, method:String, allowEnlarging:Boolean = true):Point	{		var s:Point = scale(origDimensions, containerDimensions, method, allowEnlarging);		return new Point(s.x * origDimensions.x, s.y * origDimensions.y);	}		public static function scale(origDimensions:Point, containerDimensions:Point, method:String, allowEnlarging:Boolean = true):Point	{		var sw:Number = containerDimensions.x / origDimensions.x;		var sh:Number = containerDimensions.y / origDimensions.y;		var sx:Number = sw; 		var sy:Number = sh;		if(method == BitmapDataResizerBilinear.METHOD_PAN_AND_SCAN) 	sx = sy = Math.max(sw, sh);		else if(method == BitmapDataResizerBilinear.METHOD_LETTERBOX) 	sx = sy = Math.min(sw, sh);		return new Point( (sx > 1 && !allowEnlarging ) ? 1 : sx, ( sy > 1 && !allowEnlarging ) ? 1 : sy );	}}